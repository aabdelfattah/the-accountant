// MongoDB-compatible Prisma schema for The Accountant
// Compatible with Medici for double-entry accounting

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// ============================================
// USER MANAGEMENT & AUTHENTICATION
// ============================================

model User {
  id            String    @id @default(auto()) @map("_id") @db.ObjectId
  email         String    @unique
  name          String
  password      String
  role          String    @default("USER") // ADMIN, ACCOUNTANT, USER
  active        Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  projects      Project[]
  revenues      Revenue[]
  expenses      Expense[]

  @@map("users")
}

// ============================================
// CHART OF ACCOUNTS
// ============================================

model ChartOfAccount {
  id              String             @id @default(auto()) @map("_id") @db.ObjectId
  code            String             @unique
  name            String
  type            String             // ASSET, LIABILITY, EQUITY, INCOME, EXPENSE
  parentId        String?            @db.ObjectId
  parent          ChartOfAccount?    @relation("AccountHierarchy", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  children        ChartOfAccount[]   @relation("AccountHierarchy")
  description     String?
  active          Boolean            @default(true)
  isSystem        Boolean            @default(false)

  currentBalance  Float              @default(0)

  // Track what entity created this account (for dynamic accounts)
  linkedEntityType String?           // "PROJECT", "FREELANCER", "CLIENT", "FOUNDER"
  linkedEntityId   String?           @db.ObjectId
  autoGenerated    Boolean           @default(false)

  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  // Relations
  journalLines    JournalEntryLine[]

  @@index([linkedEntityType, linkedEntityId])
  @@map("chart_of_accounts")
}

// ============================================
// CLIENTS
// ============================================

model Client {
  id                  String    @id @default(auto()) @map("_id") @db.ObjectId
  name                String
  email               String?
  phoneNumber         String?
  billingAddress      String?
  paymentTerms        String?   // e.g., "NET30", "NET15", "Due on receipt"
  active              Boolean   @default(true)

  // Linked account (auto-created AR account)
  receivableAccountId String?   @db.ObjectId

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relations
  projects            Project[]

  @@map("clients")
}

// ============================================
// FREELANCERS / VENDORS
// ============================================

model Freelancer {
  id               String    @id @default(auto()) @map("_id") @db.ObjectId
  name             String
  email            String?   @unique
  phoneNumber      String?
  paymentTerms     String?   // e.g., "Upon completion", "NET7"
  specialization   String?   // e.g., "Translator", "Editor", "PM"
  active           Boolean   @default(true)

  // Linked accounts (auto-created)
  payableAccountId String?   @db.ObjectId  // AP sub-account
  expenseAccountId String?   @db.ObjectId  // Expense sub-account

  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  expenses         Expense[]
  projectFreelancers ProjectFreelancer[]

  @@map("freelancers")
}

// ============================================
// PROJECT-FREELANCER JUNCTION (Many-to-Many)
// ============================================

model ProjectFreelancer {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId

  projectId     String      @db.ObjectId
  project       Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)

  freelancerId  String      @db.ObjectId
  freelancer    Freelancer  @relation(fields: [freelancerId], references: [id], onDelete: Cascade)

  role          String?     // e.g., "Translator", "Editor", "PM"
  assignedDate  DateTime    @default(now())

  @@unique([projectId, freelancerId])
  @@map("project_freelancers")
}

// ============================================
// PROJECTS
// ============================================

model Project {
  id              String         @id @default(auto()) @map("_id") @db.ObjectId
  name            String
  clientName      String         // Keeping for backward compatibility
  description     String?
  status          String         @default("ACTIVE") // ACTIVE, COMPLETED, ARCHIVED
  startDate       DateTime?
  endDate         DateTime?

  // Client relation
  clientId        String?        @db.ObjectId
  client          Client?        @relation(fields: [clientId], references: [id])

  userId          String         @db.ObjectId
  user            User           @relation(fields: [userId], references: [id])

  // Linked accounts (auto-created)
  revenueAccountId String?       @db.ObjectId  // Revenue account (4xxx)
  cogsAccountId    String?       @db.ObjectId  // COGS account (5xxx)

  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Relations
  revenues        Revenue[]
  expenses        Expense[]
  journalEntries  JournalEntry[]
  projectFreelancers ProjectFreelancer[]

  @@map("projects")
}

// ============================================
// REVENUE
// ============================================

model Revenue {
  id                String         @id @default(auto()) @map("_id") @db.ObjectId
  projectId         String         @db.ObjectId
  project           Project        @relation(fields: [projectId], references: [id])

  description       String
  amount            Float
  currency          String         @default("USD") // USD, EUR, EGP, GBP, SAR, AED
  exchangeRate      Float          @default(1)
  convertedAmount   Float

  revenueDate       DateTime
  invoiceDate       DateTime?
  paymentDate       DateTime?
  dueDate           DateTime?

  paymentStatus     String         @default("UNBILLED") // UNBILLED, INVOICED, PAID, OVERDUE
  bankAccount       String?

  // Tax information
  taxAmount         Float?
  withholdingAmount Float?

  userId            String         @db.ObjectId
  user              User           @relation(fields: [userId], references: [id])

  // Journal entry reference (one-to-one when paid)
  journalEntryId    String?        @db.ObjectId
  journalEntry      JournalEntry?  @relation("RevenueJournalEntry", fields: [journalEntryId], references: [id])

  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  @@map("revenues")
}

// ============================================
// EXPENSES (Both Project and Non-Project)
// ============================================

model Expense {
  id                String          @id @default(auto()) @map("_id") @db.ObjectId
  description       String
  category          String          // FREELANCER, SUBSCRIPTION, MARKETING, OPERATIONS, etc.

  // Optional project link (for COGS expenses like freelancers)
  projectId         String?         @db.ObjectId
  project           Project?        @relation(fields: [projectId], references: [id])

  // Optional freelancer link (for freelancer expenses)
  freelancerId      String?         @db.ObjectId
  freelancer        Freelancer?     @relation(fields: [freelancerId], references: [id])

  amount            Float
  currency          String          @default("USD")
  exchangeRate      Float           @default(1)
  convertedAmount   Float

  expenseDate       DateTime
  invoiceDate       DateTime?
  paymentDate       DateTime?
  dueDate           DateTime?

  paymentStatus     String          @default("PENDING") // PENDING, INVOICED, PAID
  bankAccount       String?

  // Tax information
  taxAmount         Float?
  withholdingAmount Float?

  // For recurring subscriptions
  isRecurring       Boolean         @default(false)
  recurringPeriod   String?

  userId            String          @db.ObjectId
  user              User            @relation(fields: [userId], references: [id])

  // Journal entry reference (one-to-one when paid)
  journalEntryId    String?         @db.ObjectId
  journalEntry      JournalEntry?   @relation("ExpenseJournalEntry", fields: [journalEntryId], references: [id])

  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  @@map("expenses")
}

// ============================================
// JOURNAL ENTRIES (Double-Entry Bookkeeping)
// Note: We'll use Medici for actual journal entries
// These are just references to Medici entries
// ============================================

model JournalEntry {
  id              String              @id @default(auto()) @map("_id") @db.ObjectId
  entryNumber     String              @unique
  date            DateTime
  description     String
  source          String              @default("MANUAL") // MANUAL, REVENUE, EXPENSE, SYSTEM

  // Optional references to source transactions
  projectId       String?             @db.ObjectId
  project         Project?            @relation(fields: [projectId], references: [id])

  // Note: These are logically one-to-one relations (enforced by business logic)
  // Using one-to-many in schema to avoid MongoDB unique index issues with null values
  revenues        Revenue[]           @relation("RevenueJournalEntry")
  expenses        Expense[]           @relation("ExpenseJournalEntry")

  // Status
  posted          Boolean             @default(true)
  reversed        Boolean             @default(false)
  reversalId      String?             @unique @db.ObjectId
  reversalEntry   JournalEntry?       @relation("Reversal", fields: [reversalId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  reversedBy      JournalEntry?       @relation("Reversal")

  // Medici journal entry ID reference
  mediciJournalId String?

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  // Lines (debits and credits)
  lines           JournalEntryLine[]

  @@map("journal_entries")
}

model JournalEntryLine {
  id              String         @id @default(auto()) @map("_id") @db.ObjectId

  journalEntryId  String         @db.ObjectId
  journalEntry    JournalEntry   @relation(fields: [journalEntryId], references: [id], onDelete: Cascade)

  accountId       String         @db.ObjectId
  account         ChartOfAccount @relation(fields: [accountId], references: [id])
  description     String?

  debitAmount     Float          @default(0)
  creditAmount    Float          @default(0)

  createdAt       DateTime       @default(now())

  @@map("journal_entry_lines")
}
